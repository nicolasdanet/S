
/* Copyright (c) 2024 Spaghettis and others. */

/* < https://www.gnu.org/licenses/agpl-3.0.en.html > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

namespace spaghettis {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

namespace {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

bool initializeChoice (std::vector<std::unique_ptr<juce::ToggleButton>>& buttons, const juce::String& s)
{
    for (const auto& b : buttons) {
        if (b->getButtonText() == s) {
            b->setToggleState (true, juce::NotificationType::dontSendNotification);
            return true;
        }
    }

    return false;
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

ChoicesSelector::ChoicesSelector (const juce::Value& v, const juce::StringArray& choices) : value_ (v)
{
    for (const auto& s : choices) { buttons_.push_back (std::make_unique<juce::ToggleButton> (s)); }
    
    const bool enabled = isEnabled();
    
    int index = 0;
    
    for (const auto& b : buttons_) {
    //
    b->onClick = [this, n = index++]() { setValue (n); };
    b->setEnabled (enabled);
    
    addAndMakeVisible (*b);
    //
    }
    
    // if (initializeChoice (buttons_, value_.toString()) == false) { value_.setValue (choices[0]); }
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

namespace {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

void setChoiceExclusive (std::vector<std::unique_ptr<juce::ToggleButton>>& buttons, int n)
{
    int index = 0;
    
    for (const auto& b : buttons) {
        b->setToggleState ((n == index++), juce::NotificationType::dontSendNotification);
    }
}

juce::String getChoice (std::vector<std::unique_ptr<juce::ToggleButton>>& buttons)
{
    for (const auto& b : buttons) { if (b->getToggleState()) { return b->getButtonText(); } }
    
    return juce::String();
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

void ChoicesSelector::setValue (int i)
{
    setChoiceExclusive (buttons_, i);
    
    value_.setValue (getChoice (buttons_));
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

void ChoicesSelector::paint (juce::Graphics& g)
{
    g.fillAll (Colours::fetchColour (Colours::parametersColourBackground));
}

void ChoicesSelector::resized()
{
    if (buttons_.size()) {
    //
    juce::Rectangle<int> bounds (getLocalBounds());
    
    const int h = bounds.getHeight() / buttons_.size();
    
    for (const auto& b : buttons_) { b->setBounds (bounds.removeFromTop (h)); }
    //
    }
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
