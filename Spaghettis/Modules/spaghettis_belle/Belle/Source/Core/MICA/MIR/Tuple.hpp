
/* Copyright (c) 2013 Jojo and others. */

/* < http://opensource.org/licenses/BSD-2-Clause > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

namespace MIR {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

template <int N> class Tuple {        /* Concepts grouped in a basic tuple. */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    Tuple() : tuple_()
    {
    }
    
    Tuple (const Concept (&t)[N]) : tuple_()
    {
        prim::Memory::copy (tuple_, t, N);
    }

    template <class T> Tuple (const prim::Array<T>& a, int offset = 0) : tuple_()
    { 
        int k = 0;
        for (int i = offset; i < offset + N; ++i) { if (i < a.size()) { tuple_[k++] = Concept (a[i]); } }
    }

public:
    Tuple (const Tuple<N>&) = default;
    Tuple (Tuple<N>&&) = default;
    Tuple<N>& operator = (const Tuple<N>&) = default;
    Tuple<N>& operator = (Tuple<N>&&) = default;

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

/* Make the Tuple class sortable. */

public:
    bool operator < (const Tuple& o) const
    {
        for (int i = 0; i < N; ++i) {
            if (tuple_[i] < o.tuple_[i])      { return true;  }
            else if (tuple_[i] > o.tuple_[i]) { return false; }
        }
        
        return false;
    }
  
    bool operator > (const Tuple& o) const
    {
        for (int i = 0; i < N; ++i) {
            if (tuple_[i] > o.tuple_[i])      { return true;  }
            else if (tuple_[i] < o.tuple_[i]) { return false; }
        }
        
        return false;
    }
    
    bool operator == (const Tuple& o) const
    {
        for (int i = 0; i < N; ++i) { if (tuple_[i] != o.tuple_[i]) { return false; } }
        
        return true;
    }

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

/* Make the Tuple class hashable. */

public:
    std::size_t hash() const
    {
        Concept hashed = tuple_[0];
    
        for (int i = 1; i < N; ++i) { hashed = UUID::merge (hashed, tuple_[i]); }
        
        return hashed.hash();
    }
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    Concept& operator[] (int i)
    {
        PRIM_ASSERT (i < N); return tuple_[i];
    }
    
    const Concept& operator[] (int i) const
    {   
        PRIM_ASSERT (i < N); return tuple_[i];
    }

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

public:
    Concept (&getRaw())[N]      /* < http://stackoverflow.com/a/5399014 > */
    {
        return tuple_;
    }

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

private:
    Concept tuple_[N];
    
private:
    PRIM_LEAK_DETECTOR (Tuple)
};
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

} // namespace MIR

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
