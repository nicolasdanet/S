
/* Copyright (c) 1997 Miller Puckette and others. */

/* < https://opensource.org/licenses/BSD-3-Clause > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#ifndef D_MACROS_H_
#define D_MACROS_H_

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#define DSP_UNITBIT             1572864.0   // (1.5 * 2^20)

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

#define DSP_UNITBIT_MSB         0x41380000 
#define DSP_UNITBIT_LSB         0x00000000 

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/*
    In the style of R. Hoeldrich (ICMC 1995 Banff).
    
    The trick is based on the IEEE 754 floating-point format. 
    It uses a constant offset to get the integer and the fractional parts split over
    the fourth and fifth bytes.
    Using raw cast to 32-bit integer it is therefore possible to get or to set them
    independently and (that is the goal) efficiently.
    
    Thanks to let me know links to original paper.
    
*/

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* Double precision floating-point representation (binary and hexadecimal). */

// DSP_UNITBIT
// DSP_UNITBIT + 0.5
// DSP_UNITBIT + 0.25
// DSP_UNITBIT + 0.125
// DSP_UNITBIT + 0.0625
// DSP_UNITBIT + 0.9375

// 0 10000010011 1000 00000000 00000000     00000000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000000     10000000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000000     01000000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000000     00100000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000000     00010000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000000     11110000 00000000 00000000 00000000

// 0x41380000 00000000
// 0x41380000 80000000
// 0x41380000 40000000
// 0x41380000 20000000
// 0x41380000 10000000
// 0x41380000 f0000000

// DSP_UNITBIT + 1.0
// DSP_UNITBIT + 2.0
// DSP_UNITBIT + 4.0

// 0 10000010011 1000 00000000 00000001     00000000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000010     00000000 00000000 00000000 00000000
// 0 10000010011 1000 00000000 00000100     00000000 00000000 00000000 00000000 

// 0x41380001 00000000
// 0x41380002 00000000
// 0x41380004 00000000

// DSP_UNITBIT - 0.5
// DSP_UNITBIT - 0.25
// DSP_UNITBIT - 0.125
// DSP_UNITBIT - 0.0625

// DSP_UNITBIT - 1.0
// DSP_UNITBIT - 2.0
// DSP_UNITBIT - 4.0

// 0 10000010011 0111 11111111 11111111     10000000 00000000 00000000 00000000
// 0 10000010011 0111 11111111 11111111     11000000 00000000 00000000 00000000
// 0 10000010011 0111 11111111 11111111     11100000 00000000 00000000 00000000
// 0 10000010011 0111 11111111 11111111     11110000 00000000 00000000 00000000

// 0 10000010011 0111 11111111 11111111     00000000 00000000 00000000 00000000
// 0 10000010011 0111 11111111 11111110     00000000 00000000 00000000 00000000
// 0 10000010011 0111 11111111 11111100     00000000 00000000 00000000 00000000

// 0x4137ffff 80000000
// 0x4137ffff c0000000  
// 0x4137ffff e0000000 
// 0x4137ffff f0000000

// 0x4137ffff 00000000
// 0x4137fffe 00000000
// 0x4137fffc 00000000

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#define COSINE_TABLE_SIZE       (1 << 9)    // 512

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#define COSINE_UNITBIT          (DSP_UNITBIT * COSINE_TABLE_SIZE)

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

#define COSINE_UNITBIT_MSB      0x41c80000 
#define COSINE_UNITBIT_LSB      0x00000000

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

// DSP_UNITBIT * 512.0
// DSP_UNITBIT * 512.0 + 256.0
// DSP_UNITBIT * 512.0 + 128.0
// ...

// 0 10000011100 1000 00000000 00000000     00000000 00000000 00000000 00000000
// 0 10000011100 1000 00000000 00000000     10000000 00000000 00000000 00000000
// 0 10000011100 1000 00000000 00000000     01000000 00000000 00000000 00000000

// 0x41c80000 00000000
// 0x41c80000 80000000
// 0x41c80000 40000000

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

/* Notice that the trick above is broken for index with a large value. */

/* < https://lists.puredata.info/pipermail/pd-dev/2016-11/020873.html > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

extern t_float *cos_tilde_table;

static inline t_float dsp_getCosineAtLUT (double index)
{
    t_float f1, f2, f;
    t_pun64 z;
    int i;
    
    /* Note that index MUST be <= 2^19 (i.e. 1024 * COSINE_TABLE_SIZE). */
    
    pun64_setDouble (&z, index + DSP_UNITBIT);
    
    i = (int)(pun64_getMostSignificantBytes (&z) & (COSINE_TABLE_SIZE - 1));    /* Integer part. */
    
    pun64_setMostSignificantBytes (&z, DSP_UNITBIT_MSB);
    
    f = (t_float)(pun64_getDouble (&z) - DSP_UNITBIT);      /* Fractional part. */
    
    /* Linear interpolation. */
    
    f1 = cos_tilde_table[i + 0];
    f2 = cos_tilde_table[i + 1];
    
    return (f1 + f * (f2 - f1));
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

static inline double dsp_clipForHoeldrichOverflow (double f)
{
    return PD_CLAMP (f, -1024.0, 1024.0);
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

/* Wrap the phase to [0.0, 512.0[ range. */

static double inline dsp_wrapCosine (double phase)
{
    t_pun64 z;
    pun64_setDouble (&z, phase + COSINE_UNITBIT);
    pun64_setMostSignificantBytes (&z, COSINE_UNITBIT_MSB);
    return pun64_getDouble (&z) - COSINE_UNITBIT;
}

/* Wrap the phase to [0.0, 1.0[ range. */

static double inline dsp_wrapPhasor (double phase)
{
    t_pun64 z;
    pun64_setDouble (&z, phase + DSP_UNITBIT);
    pun64_setMostSignificantBytes (&z, DSP_UNITBIT_MSB);
    return pun64_getDouble (&z) - DSP_UNITBIT;
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#define dsp_getSineAtLUT(index) dsp_getCosineAtLUT ((double)(index) - (COSINE_TABLE_SIZE / 4.0))

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

#if 0

/* Cubic Lagrange polynomial interpolation with (x0, x1, x2, x3) set to (-1, 0, 1, 2). */

static inline t_float dsp_4PointsInterpolation (t_float f, double a, double b, double c, double d)
{
    double l0 = -(f * (f - 1.0) * (f - 2.0)) / 6.0;
    double l1 = ((f + 1.0) * (f - 1.0) * (f - 2.0)) / 2.0;
    double l2 = -((f + 1.0) * f * (f - 2.0)) / 2.0;
    double l3 = ((f + 1.0) * f * (f - 1.0)) / 6.0;
    
    return ((l0 * a) + (l1 * b) + (l2 * c) + (l3 * d));
}

#endif

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* The function below is equivalent (minus rounding errors) to the more obvious one above. */
/* Note that benchmarking both doesn't show any speed difference once compiled with optimization flags. */

static inline t_float dsp_4PointsInterpolation (t_float f, double a, double b, double c, double d)
{
    double t = c - b;
    
    return (t_float)(b + f * (t - 0.1666667 * (1.0 - f) * ((d - a - 3.0 * t) * f + (d + 2.0 * a - 3.0 * b))));
}

static inline t_float dsp_4PointsInterpolationWithWords (t_float f, t_word *data)
{
    double a = (double)w_getFloat (data + 0);
    double b = (double)w_getFloat (data + 1);
    double c = (double)w_getFloat (data + 2);
    double d = (double)w_getFloat (data + 3);
    
    return dsp_4PointsInterpolation (f, a, b, c, d);
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

static inline t_sample rsqrt_fast (t_sample f)
{
    return (f <= 0.0 ? 0.0 : ((t_sample)1.0 / sqrtf (f)));
}

static inline t_sample sqrt_fast (t_sample f)
{
    return (f <= 0.0 ? 0.0 : sqrtf (f));
}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
#endif // D_MACROS_H_
