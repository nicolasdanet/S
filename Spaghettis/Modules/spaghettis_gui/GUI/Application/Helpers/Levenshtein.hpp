
/* Copyright (c) 2023 Jojo and others. */

/* < https://opensource.org/licenses/BSD-3-Clause > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* Based on < https://rosettacode.org/wiki/Levenshtein_distance >. */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

namespace spaghettis {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

template <class T, unsigned int N = 256> class Levenshtein {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    explicit Levenshtein() : key_(), length_()
    {
        v_.reserve (N);
    }
    
    ~Levenshtein() = default;

    Levenshtein (const Levenshtein&) = default;
    Levenshtein (Levenshtein&&) = default;
    Levenshtein& operator = (const Levenshtein&) = default;
    Levenshtein& operator = (Levenshtein&&) = default;

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    void setKey (const T& key)
    {
        key_    = key;
        length_ = key_.length();
    }
    
    int distanceToKey (const T& s)
    {
        return compute (s, s.length(), key_, length_);
    }

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    int distance (const T& s1, const T& s2)
    {
        return compute (s1, s1.length(), s2, s2.length());
    }

private:
    int compute (const T& s1, const int m, const T& s2, const int n)
    {
        if (m == 0) { return n; }
        if (n == 0) { return m; }
            
        v_.resize (n + 1); std::iota (v_.begin(), v_.end(), 0);
        
        int i = 0;
        
        for (auto c1 : s1) {
        //
        v_[0]       = i + 1;
        int corner  = i;
        int j       = 0;
        
        for (auto c2 : s2) {
        //
        int upper   = v_[j + 1];
        v_[j + 1]   = (c1 == c2) ? corner : 1 + std::min (std::min (upper, corner), v_[j]);
        corner      = upper;
        
        ++j;
        //
        }
        
        ++i;
        //
        }
        
        return v_[n];
    }

private:
    T key_;
    int length_;

private:
    std::vector<int> v_;

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

};

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
