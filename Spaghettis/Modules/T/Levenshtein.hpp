
/* Copyright (c) 2023 Jojo and others. */

/* < https://opensource.org/licenses/BSD-3-Clause > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* Based on < https://rosettacode.org/wiki/Levenshtein_distance >. */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

namespace spaghettis {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

template <class T, unsigned int N = 256> class Levenshtein {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    explicit Levenshtein()
    {
        v_.reserve (N);
    }
    
    ~Levenshtein() = default;

    Levenshtein (const Levenshtein&) = default;
    Levenshtein (Levenshtein&&) = default;
    Levenshtein& operator = (const Levenshtein&) = default;
    Levenshtein& operator = (Levenshtein&&) = default;
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

public:
    int distance (const T& s1, const T& s2)
    {
        const int m = s1.size();
        const int n = s2.size();
        
        if (m == 0) { return n; }
        if (n == 0) { return m; }
            
        std::vector<int> costs (n + 1);
        
        std::iota (costs.begin(), costs.end(), 0);
        
        int i = 0;
        
        for (auto c1 : s1) {
        //
        costs[0]     = i + 1;
        int corner   = i;
        int j        = 0;
        
        for (auto c2 : s2) {
        //
        int upper    = costs[j + 1];
        costs[j + 1] = (c1 == c2) ? corner : 1 + std::min (std::min (upper, corner), costs[j]);
        corner       = upper;
        
        ++j;
        //
        }
        
        ++i;
        //
        }
        
        return costs[n];
    }

private:
    std::vector<int> v_;
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

};

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
