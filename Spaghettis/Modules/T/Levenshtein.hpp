
/* Copyright (c) 2023 Jojo and others. */

/* < https://opensource.org/licenses/BSD-3-Clause > */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

/* Based on < https://rosettacode.org/wiki/Levenshtein_distance >. */

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

namespace spaghettis {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

template <class T, unsigned int N = 256> class Levenshtein {

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
// MARK: -

public:
    explicit Levenshtein()
    {
        v_.reserve (N);
    }
    
    ~Levenshtein() = default;

    Levenshtein (const Levenshtein&) = default;
    Levenshtein (Levenshtein&&) = default;
    Levenshtein& operator = (const Levenshtein&) = default;
    Levenshtein& operator = (Levenshtein&&) = default;
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

public:
    int distance (const T& s1, const T& s2)
    {
        const int m = s1.size();
        const int n = s2.size();
        
        if (m == 0) { return n; }
        if (n == 0) { return m; }
            
        v_.resize (n + 1); std::iota (v_.begin(), v_.end(), 0);
        
        int i = 0;
        
        for (auto c1 : s1) {
        //
        v_[0]       = i + 1;
        int corner  = i;
        int j       = 0;
        
        for (auto c2 : s2) {
        //
        int upper   = v_[j + 1];
        v_[j + 1]   = (c1 == c2) ? corner : 1 + std::min (std::min (upper, corner), v_[j]);
        corner      = upper;
        
        ++j;
        //
        }
        
        ++i;
        //
        }
        
        return v_[n];
    }

private:
    std::vector<int> v_;
    
// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

};

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------

}

// -----------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
